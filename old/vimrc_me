" With a map leader it's possible to do extra key combinations
" like <leader>w saves the current file
let mapleader = " "
let g:mapleader = " "

set viminfo='1000,f1,<500,h,n$MY_CONFIG_DIR/vim/viminfo

" Fast saving
noremap <leader>w :w!<cr>

" Fast editing of the .vimrc
map <leader>e :e! ~/.vimrc<cr>

" When vimrc is edited, reload it
autocmd! bufwritepost vimrc source ~/.vimrc

set formatoptions=trqno

noremap <leader>s :wa<CR>
"map <leader>q :x<CR>
noremap <leader>qq :q!<CR>
"map <leader>a :wqa<CR>
" nnoremap ; :

" from bart
noremap <leader>q :w<cr>:Bclose<cr>

command! Bclose call <SID>BufcloseCloseIt()
function! <SID>BufcloseCloseIt()
   let l:currentBufNum = bufnr("%")
   let l:alternateBufNum = bufnr("#")

   if buflisted(l:alternateBufNum)
     buffer #
   else
     bnext
   endif

   if bufnr("%") == l:currentBufNum
     new
   endif

   if buflisted(l:currentBufNum)
     execute("bdelete ".l:currentBufNum)
   endif
endfunction


""""""""""""""""""""""""""""""
" => Statusline
""""""""""""""""""""""""""""""
set laststatus=2

" Format the statusline
"set statusline=%=bufs:\ %{buftabs#statusline()}
"set statusline=%<CWD:\ %r%{CurDir()}%h\ \ %F%m%r%h\ %w\ Line:\ %l/%L:\ %p%%\ %(Column:\ %c%)
"set statusline=%<%F%m%r%h%w\ L:%l/%L\ %p%%\|%(C:%c%)%=%{buftabs#statusline()}
set statusline=%{buftabs#statusline()}%=%<\|L:%l/%L\ %p%%\|%(C:%c%)
let g:buftabs_in_statusline=1


function! CurDir()
    let curdir = substitute(getcwd(), '/Users/amir/', "~/", "g")
    return curdir
endfunction


" When pressing <leader>cd switch to the directory of the open buffer
map <leader>cd :cd %:p:h<cr>

"quick switch with alternate file
"map <leader><space> <C-^>
" correct number of lines in xmonad
"map <F4> :let &lines=&lines-1<CR>
"map <S-F4> :let &lines=&lines+1<CR>

" Enable filetype plugin
filetype plugin on
filetype indent on

" Set to auto read when a file is changed from the outside
set autoread

" allows to recover cut text in insert mode
" std st 

inoremap <c-u> <c-g>u<c-u>
inoremap <c-w> <c-g>u<c-w>


"map <leader>j j
"map <leader>h h
"map <leader>k k
"map <leader>l l

" yankring file will be saved here
let g:yankring_history_dir = '$MY_CONFIG_DIR/vim'
"let g:yankring_manage_numbered_reg = 1

noremap <silent> <F10> :YRShow <CR>
" TODO: deleted place text in numbered registers
"map x @'x
"map c ""c
"map d ""d

" nerdtree
nnoremap <leader>d :NERDTreeToggle<CR>
let NERDTreeMapActivateNode='<CR>'
let g:NERDTreeWinSize=29

set visualbell
set showcmd
set timeoutlen=400

set cursorline
"hi CursorLine guibg=LightGray
"hi CursorLine cterm=LightGray

set smartcase          " Do smart case matching
set autowriteall " Automatically save before commands like :next and :make
set autochdir
set hidden             " Hide buffers when they are abandoned
set wildmode=list:longest " Completion type
set gdefault

""  "Show the miniBufExplorer when more than 2 files are edited
""  " now by default
""  "let g:miniBufExplorerMoreThanOne = 2
""  let g:miniBufExplMaxSize = 4
""  " GRB: use fancy buffer closing that doesn't close the split
""  "cnoremap <expr> bd (getcmdtype() == ':' ? 'Bclose' : 'bd')
""  
""  " If you use other explorers like TagList you can (As of 6.2.8) set it at 1:
""  let g:miniBufExplModSelTarget = 1
""  
""  let g:miniBufExplMapWindowNavVim = 1
""  "let g:miniBufExplMapWindowNavArrows = 1
""  let g:miniBufExplMapCTabSwitchBufs = 1
""  "let g:miniBufExplModSelTarget = 1
""  " C-J does not work...
""  "noremap <C-J> <C-W>j
""  
""  "autocmd BufEnter,BufRead,BufNew,BufLeave,BufHidden,BufDelete :call UMiniBufExplorer
""  autocmd BufRead,BufNew :call UMiniBufExplorer
""  
""  map <leader>u :TMiniBufExplorer<cr>
""  
""  "let g:miniBufExplForceSyntaxEnable = 1
""  
""  " buffers that have NOT CHANGED and are VISIBLE
""  "highlight MBEVisibleNormal term=bold cterm=bold gui=bold 
""  "hi link MBEVisibleChanged Todo
""  "hi link MBEVisibleNormal Todo

" for not messing up windows with nerdtree and all
" Delete buffer while keeping window layout (don't close buffer's windows).
" Version 2008-11-18 from http://vim.wikia.com/wiki/VimTip165
if v:version < 700 || exists('loaded_bclose') || &cp
finish
endif
let loaded_bclose = 1
if !exists('bclose_multiple')
let bclose_multiple = 1
endif

" Display an error message.
function! s:Warn(msg)
echohl ErrorMsg
echomsg a:msg
echohl NONE
endfunction

" Command ':Bclose' executes ':bd' to delete buffer in current window.
" The window will show the alternate buffer (Ctrl-^) if it exists,
" or the previous buffer (:bp), or a blank buffer if no previous.
" Command ':Bclose!' is the same, but executes ':bd!' (discard changes).
" An optional argument can specify which buffer to close (name or number).
function! s:Bclose(bang, buffer)
if empty(a:buffer)
let btarget = bufnr('%')
elseif a:buffer =~ '^\d\+$'
let btarget = bufnr(str2nr(a:buffer))
else
let btarget = bufnr(a:buffer)
endif
if btarget < 0
call s:Warn('No matching buffer for '.a:buffer)
return
endif
if empty(a:bang) && getbufvar(btarget, '&modified')
call s:Warn('No write since last change for buffer '.btarget.' (use :Bclose!)')
return
endif
" Numbers of windows that view target buffer which we will delete.
let wnums = filter(range(1, winnr('$')), 'winbufnr(v:val) == btarget')
if !g:bclose_multiple && len(wnums) > 1
call s:Warn('Buffer is in multiple windows (use ":let bclose_multiple=1")')
return
endif
let wcurrent = winnr()
for w in wnums
execute w.'wincmd w'
let prevbuf = bufnr('#')
if prevbuf > 0 && buflisted(prevbuf) && prevbuf != w
buffer #
else
bprevious
endif
if btarget == bufnr('%')
" Numbers of listed buffers which are not the target to be deleted.
let blisted = filter(range(1, bufnr('$')), 'buflisted(v:val) && v:val != btarget')
" Listed, not target, and not displayed.
let bhidden = filter(copy(blisted), 'bufwinnr(v:val) < 0')
" Take the first buffer, if any (could be more intelligent).
let bjump = (bhidden + blisted + [-1])[0]
if bjump > 0
execute 'buffer '.bjump
else
execute 'enew'.a:bang
endif
endif
endfor
execute 'bdelete'.a:bang.' '.btarget
execute wcurrent.'wincmd w'
endfunction
command! -bang -complete=buffer -nargs=? Bclose call <SID>Bclose('<bang>', '<args>')
nnoremap <silent> <Leader>bd :Bclose<CR>
nnoremap <silent> <Leader>bD :Bclose!<CR>

""  "tabbar settings
""  let g:Tb_SplitBelow=1       " Put the tabbar at the bottom
""  let g:Tb_MaxSize=0          " I want it to automatically resize if I have buffers that fill more then one line
""  let g:Tb_MoreThanOne=0      " I want the tabbar to be always visible
""  let g:Tb_ModSelTarget = 1
"let g:buftabs_only_basename=1

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Map space to / (search) and c-space to ? (backgwards search)
"map <space> /
"map <S-space> ?
map <silent> <leader><space> :noh<cr>



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Text, tab and indent related
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set smarttab

set linebreak

set ai "Auto indent
set si "Smart indet
set wrap "Wrap lines
set sidescroll=4
set listchars+=precedes:<,extends:>

"map <leader>t2 :setlocal shiftwidth=2<cr>
"map <leader>t4 :setlocal shiftwidth=4<cr>
"map <leader>t8 :setlocal shiftwidth=4<cr>

set expandtab
"autocmd BufRead *.py set textwidth=79
set textwidth=79
autocmd BufRead *.py match ErrorMsg '\%>80v.\+'
set tabstop=4
set softtabstop=4
set shiftwidth=4
set autoindent

"

syntax on


set guioptions-=Tm
set hlsearch
set showmatch
" set number

let Tlist_Ctags_Cmd='/usr/bin/ctags'
" map T :TaskList<CR>
map <silent> <Leader>tf :.,'}call <Plug>NormalTableMode0<cr>
nnoremap <leader>t :TlistToggle<CR>:TlistUpdate<cr>
" taglist open on the right
let Tlist_Use_Right_Window = 1

filetype on            " enables filetype detection
filetype plugin on     " enables filetype specific plugins
filetype indent on 

" remove trailing spaces with F11
map <F11> :%s/\s\+$//g<CR>:nohlsearch<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" PYTHON
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
autocmd filetype python set omnifunc=pythoncomplete#Complete
" autocompletion with   (Ctrl-Space) 
inoremap <Nul> <C-x><C-o>
" make python
"autocmd BufRead *.py set makeprg=python\ -c\ \"import\ py_compile,sys;\ sys.stderr=sys.stdout;\ py_compile.compile(r'%')\"
"autocmd BufRead *.py set efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m 
autocmd FileType python compiler pylint
let g:pylint_onwrite = 0
let g:pylint_show_rate = 1
let g:pylint_cwindow = 1
"let g:pyflakes_use_quickfix = 0
" really nice linewidth settings depending on comment
" from: http://stackoverflow.com/questions/4027222/vim-use-shorter-textwidth-in-comments-and-docstrings
" does not work ;(

function! GetPythonTextWidth()
    if !exists('g:python_normal_text_width')
        let l:normal_text_width = 79
    else
        let l:normal_text_width = g:python_normal_text_width
    endif

    if !exists('g:python_comment_text_width')
        let l:comment_text_width = 72
    else
        let l:comment_text_width = g:python_comment_text_width
    endif

    let l:cur_syntax = synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name")
    if l:cur_syntax == "Comment"
        return l:comment_text_width
    elseif l:cur_syntax == "String"
        " Check to see if we're in a docstring
        let l:lnum = line(".")
        while l:lnum >= 1 && synIDattr(synIDtrans(synID(l:lnum, col([l:lnum, "$"]) - 1, 0)), "name") == "String"
            if match(getline(l:lnum), "\\('''\\|\"\"\"\\)") > -1
                " Assume that any longstring is a docstring
                return l:comment_text_width
            endif
            let l:lnum -= 1
        endwhile
    endif

    return l:normal_text_width
endfunction

augroup pep8
    au!
    autocmd CursorMoved,CursorMovedI *.py :if &filetype == 'python' | :exe 'setlocal textwidth='.GetPythonTextWidth() | :endif
augroup END

" from: http://www.sontek.net/python-with-a-modular-ide-vim
"for all imports
python << EOF
import os
import sys
import vim
for p in sys.path:
    if os.path.isdir(p):
        vim.command(r"set path+=%s" % (p.replace(" ", r"\ ")))
EOF

"This will give you the ability to use CTRL+] to jump to the method/property
"under your cursor in the system libraries and CTRL+T to jump back to your
"source code.
"$ ctags -R -f ~/.vim/tags/python.ctags /usr/lib/python2.5/
set tags+=$HOME/.vim/tags/python.ctags

"doautocmd pep8 BufEnter *.py

" function! s:MyPythonSettings()
setlocal autoindent
" for python syntax folder plugin
let python_highlight_all=1
let python_space_errors=1
let python_no_tab_space_error=1
let python_print_as_function = 1
let python_slow_sync = 1

let g:pydiction_location = '/home/louis/config/vim/pydiction-1.2/complete-dict'

" Insert and remove comments markers
"map - :s/^/#/<CR>:nohlsearch<CR>
"map + :s/^#//<CR>:nohlsearch<CR>
"let loaded_nerd_comments=1
let NERDCreateDefaultMappings=0
nmap g- <Plug>NERDCommenterComment
nmap g+ <Plug>NERDCommenterUncomment

" Insert wrapping comments around a single line
"map { :s/^\(.*\)$/"""&"""/<CR>:nohlsearch<CR>
    
" endfunction   

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map go o
map gO O
map gK ih
map gJ i
" map Ctrl-A, Ctrl-E, and Ctrl-K in insert mode. 
imap <C-A> <Home>
" imap <C-E> <End>
"imap <C-K> <Esc>lDa
imap <C-F> <C-O>J

" Turn off incremental searching for files over 10,000,000 bytes. It's too
" slow.
function! IncSearch()
    if line2byte(line("$")) < 10000000
        set incsearch
    else
        set noincsearch
    endif
endfunction

autocmd BufReadPost * call IncSearch()

" open file at previous known position
if has("autocmd")
autocmd BufReadPost *
            \ if line("'\"") > 0 && line("'\"") <= line("$") |
            \ exe "normal g'\"" |
            \ endif
endif


" automatically insert "#!/bin/sh" line for *.sh files
au BufEnter *.sh if getline(1) == "" | :call setline(1, "#!/bin/sh") | endif
" idem for python
au BufEnter *.py if getline(1) == "" | :call setline(1, "#!/usr/bin/env python") | endif

" Define a function that can tell me if a file is executable
function! FileExecutable (fname)
  execute "silent! ! test -x" a:fname
  return v:shell_error
endfunction
" Automatically make Python and Shell scripts executable if they aren't already
au BufWritePost *.sh,*.py if FileExecutable("%:p") | silent !chmod a+x %   endif



" These settings are needed for latex-suite

"au FileType tex so ~/.vim/ftplugin/tex_latexSuite.vim

"let g:tex_flavor='latex'
"set grepprg=grep\ -nH\ $*
"set runtimepath+=/usr/share/vim/addons/
filetype plugin on
set grepprg=grep\ -nH\ $*
"filetype indent on
""  " commented since switch from latex-suite to auctex
""  let g:tex_flavor='latex'
""  " execute ":TTarget<CR>"
""  " au FileType tex so ~/.vim/ftplugin/tex_latexSuite.vim
""  imap <buffer> ii<space> <Plug>Tex_InsertItemOnThisLine
""  "silent inoremap <space>
""  " REPLIS: vim-latex replis automatiquement certaines sections et environnements
""  " ou commandes. La liste de ce qui doit être replié est géré par les varibales
""  " globales suivantes. Les replis se font en partant de la fin de la liste puis
""  " en remontant. Les defaut sont dans folding.vim (~/.vim/ftplugin/latex-suite/)
""  let g:Tex_FoldedSections="part,chapter,section" 
""  ",%%fakesection,subsection"
""  let g:Tex_FoldedEnvironments="verbatim,comment,eq,figure,table,tabular,tikzpicture,thebibliography,abstract,frame"
""  let g:Tex_FoldedMisc = 'preamble,<<<'  " >>>
""  let g:Tex_MultipleCompileFormats="pdf"
""  
""  " COMPILATION VISUALISATION: par defaut on compile avec pdflatex et on utilise
""  let g:Tex_ViewRule_pdf = "evince"
""  let g:Tex_DefaultTargetFormat="pdf"

" supertab completion
"let g:SuperTabDefaultCompletionType = "<c-x><c-u>"
"let g:SuperTabDefaultCompletionType = "<c-x><c-o>"
let g:SuperTabDefaultCompletionType = "context"
let g:SuperTabContextDefaultCompletionType = "<c-p>"

""  let g:SuperTabCompletionContexts = ['s:ContextText', 's:ContextDiscover']
""  let g:SuperTabContextTextOmniPrecedence = ['&omnifunc', '&completefunc']
""  let g:SuperTabContextDiscoverDiscovery = ['&omnifunc:<c-x><c-o>', '&completefunc:<c-x><c-u>'] 
"let tlist_tex_settings   = 'latex;s:section;g:graphic;l:label'


" haskell

" use ghc functionality for haskell files
" au Bufenter *.hs compiler ghc
" configure browser for haskell_doc.vim
let g:haddock_browser = "/usr/bin/iceweasel"
let g:haddock_docdir = "/home/louis/doc/haddock-html"

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Spell checking
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" F8 toggles spelling
nnoremap <F8> :setlocal spell!<cr>
"Pressing ,ss will toggle and untoggle spell checking
"map <leader>ss :setlocal spell!<cr>

"Shortcuts using <leader>
map <leader>n ]s
map <leader>p [s
"map <leader>z zg
map <leader>r z=

let g:EasyGrepMode = 1

nnoremap <leader>a :Ack
map <leader>g :vimgrep // **/*.<left><left><left><left><left><left><left>

" F2 shows relative line numbers
nnoremap <F2> :call RltvNmbr#RltvNmbrCtrl(1)<cr>
" F3 unshows relative line numbers
nnoremap <F3> :call RltvNmbr#RltvNmbrCtrl(0)<cr>

" Rainbow parenthesis
nnoremap <F4> :ToggleRaibowParenthesis<cr>

" set undofile
vnoremap gj j
nnoremap gj j
vnoremap gk k
nnoremap gk k

vnoremap j gj
nnoremap j gj
vnoremap k gk
nnoremap k gk

" for restructured text
imap  yypVr-o
map <leader>z yypVr
autocmd BufEnter *.txt set syntax=rst
autocmd BufEnter *.txt set nowrap
map <leader>x :w<cr>:silent !rst2html % > %.html<cr>
"autocmd BufRead *.txt map <leader>ll :silent !rst2html % > %.html

" for wiki à la google code
autocmd BufNewFile,BufRead *.wiki set ft=googlecodewiki

" readjust sentence
map <leader>o gqis

""""""""""""""""""""""""""""""
" => Fuzzy finder
""""""""""""""""""""""""""""""
try
    call fuf#defineLaunchCommand('FufCWD', 'file', 'fnamemodify(getcwd(), ''%:p:h'')')
    map <leader>f :FufCWD **/<CR>
catch
endtry

" for tms
let g:tmsrc = expand($MY_CONFIG_DIR . '/vim/mail/_tmsrc')

" for showmarks
let g:showmarks_enable = 0
    

"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" => Parenthesis/bracket expanding
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"vnoremap <leader>1 <esc>`>a)<esc>`<i(<esc>
"vnoremap <leader>2 <esc>`>a]<esc>`<i[<esc>
"vnoremap <leader>3 <esc>`>a}<esc>`<i{<esc>
"vnoremap <leader>$ <esc>`>a"<esc>`<i"<esc>
"vnoremap <leader>q <esc>`>a'<esc>`<i'<esc>
"vnoremap <leader>e <esc>`>a"<esc>`<i"<esc>
"
"" Map auto complete of (, ", ', [
"inoremap <leader>1 ()<esc>i
"inoremap <leader>2 []<esc>i
"inoremap <leader>3 {}<esc>i
"inoremap <leader>4 {<esc>o}<esc>O
"inoremap <leader>q ''<esc>i
"inoremap <leader>e ""<esc>i

let g:acp_enableAtStartup = 0
let g:acp_behaviorSnipmateLength = 1

" snipmate
let g:snips_author = 'Louis Plissonneau'
"source $MY_CONFIG_DIR/vim/after/plugin/snipMate.vim

